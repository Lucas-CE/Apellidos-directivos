<!DOCTYPE html>
<html lang="en">
    <head>
        <title>Apellidos directivos</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <!-- Bootstrap CSS CDN -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
        <style>
            body {
                text-align: left;
                font-family: 'Arial', sans-serif;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            .main-cont {
                max-width: 95vw;
                max-height: 100vh;
                margin: 0 auto;
            }

            h1 {
                font-weight: bold;
                color: #333;
            }

            .network-graph {
                height: 69vh;
                text-align: left;
                border: 1px solid #ccc;
                background-color: #f9f9f9;
            }

            .network-graph canvas {
                margin: 0;
                padding: 0;
                width: 100%;
                height: 100%;
            }

            .plot-container {
                width: 33vw;
                height: 80vh;
            }

            .global-vis-sub-container {
                width: 100%;
                height: 50%;
                border: 1px solid #ccc;
            }

            .hover-edge {
                stroke: #000000; /* Color de las aristas destacadas */
                stroke-width: 2px;
            }

            .dominant-surname-vis {
                margin: auto;
                width: 100%;
            }

            .powerful-surename-wordcloud {
                padding: 0.5%;
                margin: 0.5%;
                width: 43%;
                border: 1px solid #ccc;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            }


        </style>
        <meta charset="utf-8" />
        <script type="text/javascript">window.PlotlyConfig = {MathJaxConfig: 'local'};</script>
        <!-- Bootstrap JS and Popper.js (optional) -->
        <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.9.2/dist/umd/popper.min.js"></script>
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
        <script src="js/plotly-2.35.2.min.js"></script>
        <script src="js/graphology.min.js"></script>
        <script src="js/graphology-library.min.js"></script>
        <script src="js/sigma.min.js"></script>
    </head>

    <body>
        <div class="main-cont container mt-4">
            <h1 class="mb-4">Apellidos de los directivos de empresas Chilenas</h1>
            <div class="d-flex flex-row">
                <!-- Grafo -->
                <div class="graph-container">
                    <h4>Grafo de empresas y los apellidos de los directivos que han tenido</h4>
                    <p class="fw-light text-secondary">
                        El ancho de las aristas indica la cantidad de veces que un apellido ha aparecido en algún directivo de una empresa.
                    </p>
                    <div id="surename-graph" class="network-graph"></div>
                </div>
                <!-- Gráficos de barras -->
                <div class="plot-container d-flex flex-column ml-1">
                    <div id="bar-chart-1" class="global-vis-sub-container mb-1"></div>
                    <div class="global-vis-sub-container mt-1">
                        <img 
                            id="wordcloud" 
                            src="wordcloud.png" 
                            alt="Nube de Palabras"
                            width="100%"
                        />
                    </div>
                </div>
            </div>
        </div>

        <div class="main-cont container mt-5">
            <h1 class="mb-4">Existen familias que podrían tener mucho poder en una empresa?</h1>
            <div class="d-flex flex-row">
                <div id="bar-chart-2" class="dominant-surname-vis"></div>
            </div>
        </div>

        <div class="main-cont container mt-5">
            <h1 class="mb-1">Hay familias con poder en muchas empresas?</h1>
            <div class="d-flex flex-column">
                <div class="d-flex flex-row">
                    <div class="d-flex flex-column powerful-surename-wordcloud">
                        <h4><b></b>Empresas relacionadas con el apellido LARRAIN</b></h4>
                        <img 
                            src="LARRAIN_wordcloud.png" 
                            alt="Nube de Palabras" 
                            class="wordcloud"
                        />
                    </div>
                    <div class="d-flex flex-column powerful-surename-wordcloud">
                        <h4><b></b>Empresas relacionadas con el apellido VIAL</b></h4>
                        <img 
                            src="VIAL_wordcloud.png" 
                            alt="Nube de Palabras" 
                            class="wordcloud"
                        />
                    </div>
                </div>
                <div class="d-flex flex-row">
                    <div class="d-flex flex-column powerful-surename-wordcloud">
                        <h4><b></b>Empresas relacionadas con el apellido ECHEVERRIA</h4>
                        <img 
                            src="ECHEVERRIA_wordcloud.png" 
                            alt="Nube de Palabras" 
                            class="wordcloud"
                        />
                    </div>
                    <div class="d-flex flex-column powerful-surename-wordcloud">
                        <h4><b></b>Empresas relacionadas con el apellido ERRAZURIZ</h4>
                        <img 
                            src="ERRAZURIZ_wordcloud.png" 
                            alt="Nube de Palabras" 
                            class="wordcloud"
                        />
                    </div>
                </div>
            </div>
        </div> 

        <script>
            // Cargar datos del histograma desde un archivo JSON
            fetch("bar_data.json")
            .then((res) => res.json())
            .then((data) => {
                // Renderizar gráficos de barras con Plotly
                Plotly.newPlot('bar-chart-1', [{
                    x: data.x,
                    y: data.y,
                    type: 'bar',
                    marker: { color: 'purple' }
                }], {
                    title: 'Distribución de repeticiones de apellido en una empresa',
                    xaxis: { title: 'Número de apariciones de un apellido en una empresa' },
                    yaxis: { title: 'Frecuencia' }
                });
            });
            fetch("bar_dominant_surname_data.json")
            .then((res) => res.json())
            .then((data) => {
                // Renderizar gráficos de barras con Plotly
                Plotly.newPlot('bar-chart-2', [{
                    x: data.x,
                    y: data.y,
                    type: 'bar',
                    orientation: 'h', // Configura las barras horizontales
                    marker: { color: 'purple' }
                }], {
                    title: 'Distribución de repeticiones de apellido en una empresa',
                    margin: { l: 250 },
                    xaxis: { title: 'Número de apariciones de apellido en una empresa' }
                });
            });

            function renderGraph(graphContainerId, gexFilePath){
                fetch(gexFilePath)
                .then((res) => res.text())
                .then((res) => {
                    let graph = graphologyLibrary.gexf.parse(graphology.Graph, res);
                    const container = document.getElementById(graphContainerId);

                    // Calcular grados para nodos
                    const degrees = graph.nodes().map((node) => graph.degree(node));
                    const minDegree = Math.min(...degrees);
                    const maxDegree = Math.max(...degrees);
                    const minSize = 2, maxSize = 8;

                    let selectedNode = null; // Variable global para el nodo seleccionado
                    let hoverNode = null; // Variable global para el nodo sobre el que se pasa el mouse

                    graph.forEachNode((node) => {
                        // Ajustar el tamaño según el grado
                        const degree = graph.degree(node);
                        
                        graph.setNodeAttribute(
                            node,
                            "size",
                            minSize + ((degree - minDegree) / (maxDegree - minDegree)) * (maxSize - minSize)
                        );
                
                        // Colorear nodos según el atributo "color"
                        const color = graph.getNodeAttribute(node, "color") || "#ccc";
                        graph.setNodeAttribute(node, "color", color);

                        // Obtener el nombre original del nodo
                        const originalLabel = graph.getNodeAttribute(node, "label");

                        // Truncar nombres largos
                        const maxLength = 10; // Máximo de caracteres antes de truncar
                        const truncatedLabel =
                            originalLabel.length > maxLength
                                ? originalLabel.substring(0, maxLength) + "..."
                                : originalLabel;

                        // Guardar el nombre completo
                        graph.setNodeAttribute(node, "fullLabel", originalLabel);

                        // Guardamos el nombre truncado en otro atributo
                        graph.setNodeAttribute(node, "truncatedLabel", truncatedLabel);

                        // Usar el nombre truncado como etiqueta
                        graph.setNodeAttribute(node, "label", truncatedLabel);
                    });


                    // Ajustar tamaño de las aristas según el peso
                    graph.forEachEdge((edge) => {
                        const weight = graph.getEdgeAttribute(edge, "conteo") || 1; // Usar atributo 'conteo'
                        const minWeight = 1, maxWeight = 10;
                        const scaledWeight =
                            minWeight + ((weight - minDegree) / (maxDegree - minDegree)) * (maxWeight - minWeight);
                        graph.setEdgeAttribute(edge, "size", scaledWeight ** 1.5);
                    });              
                        

                    // Layout inicial circular para evitar superposiciones
                    graphologyLibrary.layout.circular.assign(graph);

                    // Aplicar ForceAtlas2 para organizar el grafo
                    graphologyLibrary.layoutForceAtlas2.assign(graph, {
                        iterations: 300,
                        getEdgeWeight: (edge) => graph.getEdgeAttribute(edge, "conteo"),
                        settings: {
                            strongGravityMode: true,
                            gravity: 0.3,
                            scalingRatio: 10,
                            slowDown: 1,
                        },
                    });

                    // Renderizar el grafo con Sigma
                    const renderer = new Sigma(graph, container);

                    renderer.on("enterNode", (event) => {
                        const node = event.node;
                        if (hoverNode) {
                            graph.updateNodeAttribute(hoverNode, "hover", () => false);
                            const truncatedLabel = graph.getNodeAttribute(hoverNode, "truncatedLabel");
                            graph.updateNodeAttribute(hoverNode, "label", () => truncatedLabel);
                        }
                        hoverNode = node;
                        graph.updateNodeAttribute(node, "hover", () => true);
                        const fullLabel = graph.getNodeAttribute(node, "fullLabel");
                        graph.updateNodeAttribute(node, "label", () => fullLabel);
                        renderer.refresh();
                    });

                    // Evento: al hacer clic en un nodo
                    renderer.on("clickNode", ({ node }) => {
                        // Limpiar el nodo previamente seleccionado (si existe)
                        if (selectedNode) {
                            graph.updateNodeAttribute(selectedNode, "highlighted", () => false);
                            graph.forEachEdge(selectedNode, (edge) => {
                                // Obtenemos el nodo que conecta con el nodo seleccionado
                                const target = graph.opposite(selectedNode, edge);
                                const truncatedLabel = graph.getNodeAttribute(target, "truncatedLabel");
                                // Actualizamos el label del nodo opuesto
                                graph.updateNodeAttribute(target, "label", () => truncatedLabel);
                                graph.updateEdgeAttribute(edge, "highlighted", () => false);
                            });

                            // Actualizar label del nodo previamente seleccionado
                            const truncatedLabelSelectedNode = graph.getNodeAttribute(selectedNode, "truncatedLabel");
                            graph.updateNodeAttribute(selectedNode, "label", () => truncatedLabelSelectedNode);
                        }
                    
                        // Actualizar el nodo actualmente seleccionado
                        selectedNode = node;
                    
                        // Resaltar el nuevo nodo seleccionado y sus aristas
                        graph.updateNodeAttribute(node, "highlighted", () => true);
                        graph.forEachEdge(node, (edge) => {
                            // Obtenemos el nodo que conecta con el nodo seleccionado
                            const target = graph.opposite(selectedNode, edge);
                            const completeLabel = graph.getNodeAttribute(target, "fullLabel");
                            // Actualizamos el label del nodo opuesto
                            graph.updateNodeAttribute(target, "label", () => completeLabel);
                            graph.updateEdgeAttribute(edge, "highlighted", () => true);
                        });

                        // Actualizar label del nodo seleccionado
                        const fullLabelSelectedNode = graph.getNodeAttribute(node, "fullLabel");
                        graph.updateNodeAttribute(node, "label", () => fullLabelSelectedNode);
                    
                        renderer.refresh(); // Actualizar el grafo
                    });
                    
                    // Evento: al tocar otro lugar (vacío) del grafo
                    renderer.on("clickStage", () => {
                        if (selectedNode) {
                        // Limpiar el nodo seleccionado y sus aristas
                        graph.updateNodeAttribute(selectedNode, "highlighted", () => false);
                        graph.forEachEdge(selectedNode, (edge) => {
                            // Obtenemos el nodo que conecta con el nodo seleccionado
                            const target = graph.opposite(selectedNode, edge);
                            const truncatedLabel = graph.getNodeAttribute(target, "truncatedLabel");
                            // Actualizamos el label del nodo opuesto
                            graph.updateNodeAttribute(target, "label", () => truncatedLabel);
                            graph.updateEdgeAttribute(edge, "highlighted", () => false);
                        });

                        // Actualizar label del nodo previamente seleccionado
                        const truncatedLabelSelectedNode = graph.getNodeAttribute(selectedNode, "truncatedLabel");
                        graph.updateNodeAttribute(selectedNode, "label", () => truncatedLabelSelectedNode);
                        
                        selectedNode = null; // Reiniciar el nodo seleccionado
                        renderer.refresh(); // Actualizar el grafo
                        }
                    });
                    renderer.setSetting("nodeReducer", (node, data) => {
                        if (data.highlighted) {
                            return { ...data, color: "#000000", zIndex: 1 }; // Nodo destacado
                        }
                        return data;
                    });
                        
                    renderer.setSetting("edgeReducer", (edge, data) => {
                        if (data.highlighted) {
                            return { ...data, color: "#000000", size: 2 }; // Arista destacada
                        }
                        return data;
                    });
                });
            }
            renderGraph("surename-graph", "graph_most_relevant_directors_surnames.gexf");
            renderGraph("dominant-surname", "graph_surname_relevant_in_some_company.gexf");
        </script>
    </body>
</html>
    